# Документация проекта "Tool Recognition"

## 1. Обзор проекта

Сервис автоматизации учёта инструментов предназначен для инженерно‑технического персонала, обслуживающего авиационную технику. В настоящее время сотрудники комплектовочных складов тратят много времени на ручной пересчёт инструмента, что ведёт к очередям и ошибкам. Проект предлагает сервис компьютерного зрения, который распознаёт инструменты на изображениях и автоматически формирует отчёт о соответствии набора — это позволяет повысить эффективность работы, сократить время ожидания и предотвратить потери.

Основные возможности сервиса, заявленные в репозитории, включают автоматическое распознавание инструментов на фото, сравнение полученного набора с ожидаемым, уведомления о недостаче, веб‑интерфейс для загрузки изображений, REST API с Swagger UI, сохранение изображений (сырых и с разметкой) в S3‑совместимом хранилище и формирование JSON‑отчётов.

## 2. Детализированные требования

### 2.1 Функциональные требования

1. **Распознавание инструментов**. Сервис принимает изображение или набор изображений (в том числе ZIP‑архив) через API и возвращает JSON‑отчёт с классификацией и координатами обнаруженных инструментов.
2. **Сравнение набора с эталоном**. В системе хранится список ожидаемых инструментов для каждого класса (11 классов инструментов). В отчёте указывается число найденных и отсутствующих инструментов, процент совпадения и список недостающих элементов.
3. **Сохранение изображений**. Сырой снимок и визуализация с нанесёнными bounding‑box сохраняются в объектное хранилище MinIO; в ответе возвращаются URL‑адреса для доступа к этим изображениям.
4. **Запись транзакций**. Для каждой операции создаётся уникальный идентификатор транзакции и порядковый номер. Результаты операции сохраняются в таблице `transactions` базы данных PostgreSQL.
5. **REST API**. Предоставляются эндпойнты:
   - `GET /` и `GET /health` для проверки работоспособности сервиса;
   - `GET /model/info` — возвращает статус модели, список классов и тип задачи;
   - `GET /minio/presigned` — выдаёт временную ссылку на файл в MinIO;
   - `POST /predict/single` — обработка одной картинки;
   - `POST /predict/batch` — обработка нескольких файлов;
   - `POST /predict/zip` — обработка ZIP‑архива с изображениями.
6. **Пользовательский интерфейс**. Веб‑интерфейс React позволяет загрузить одно или несколько изображений либо ZIP‑файл, выводит информацию о состоянии модели и подробно отображает результаты распознавания (таблицы, проценты совпадения, список найденных и отсутствующих инструментов).

### 2.2 Нефункциональные требования

- **Производительность**: обработка одного изображения должна укладываться в несколько секунд; API рассчитан на асинхронную работу и может обрабатывать пачку файлов параллельно.
- **Надёжность**: сервис должен корректно работать при недоступности модели (выдавать ошибку 500), при отсутствии изображений в запросе (ошибка 400) и при невозможности декодировать файл (возврат статуса `error` с пояснением).
- **Масштабируемость**: компоненты разворачиваются в контейнерах и могут масштабироваться независимо посредством Docker Compose; подключение к базе данных и MinIO задаётся через переменные окружения, что позволяет легко перенести сервис в облако.
- **Безопасность**: доступ к API может быть ограничен CORS; для хранения данных используется S3‑совместимое хранилище с ключами доступа, а доступ к базе данных защищён учётными данными.

## 3. Архитектура

### 3.1 Общий обзор

Сервис построен по микросервисной схеме и разворачивается в инфраструктуре Docker Compose. Основные компоненты:

| Компонент                | Назначение                                                                                                                                                                                                                                                                                                                      | Важные детали                                                                                                                                                                                                                                                                                     |
| --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Backend** (FastAPI)       | REST API для приёма изображений, выполнения инференса модели, сохранения результатов и выдачи отчётов. Загружает модель YOLO при старте и инициализирует подключение к базе данных и MinIO. | Эндпойнты /health, /predict/*, /model/info; использует SQLAlchemy для работы с PostgreSQL; сохраняет картинки в MinIO; загружает веса YOLO из файла `best.pt`.                                                                           |
| **ML Model (YOLO-seg 11n)** | Сегментационная модель Ultralytics, загружается из checkpoint `best.pt` и предоставляет возможность детектировать bounding‑box каждого инструмента.                                                                                          | Конфигурация модели загружается один раз, хранится глобально в приложении; список классов задаётся как массив словарей с `class_id`, `name` и соответствием имени модели. |
| **MinIO**                   | S3‑совместимое хранилище для сохранения исходных и размеченных изображений.                                                                                                                                                                                              | Сервис при старте создаёт нужные бакеты (например,`raw-images` и `viz-images`) и сохраняет туда файлы.                                                                                                                                      |
| **PostgreSQL**              | Сохраняет результаты транзакций (JSON отчёты) для дальнейшего анализа.                                                                                                                                                                                                            | Используется SQLAlchemy; таблица `transactions` содержит поля `id`, `sequence_number`, `created_at` и `data`.                                                                                                                                                       |
| **Frontend (React)**        | Веб‑интерфейс для пользователя; обеспечивает загрузку файлов, отображение результатов и информации о модели.                                                                                                                                | Использует Vite, React 18 и axios для взаимодействия с API; компоненты `FileUploader`, `ResultsViewer` и `ModelInfo` реализуют основные функции интерфейса.                                                                   |

Docker Compose файл описывает взаимосвязь сервисов. Backend строится из каталога `backend`, проксируется на порт 8000 и зависит от базы данных и MinIO; frontend собирается из каталога `frontend` и работает на порту 3000; база данных Postgres и MinIO разворачиваются как отдельные контейнеры. Среда исполняется в сетевом окружении docker, что упрощает локальный запуск и переносимость.

### 3.2 Поток данных

1. **Загрузка изображений**. Пользователь через веб‑интерфейс загружает файл (или ZIP) на один из эндпойнтов. Frontend отправляет запрос на backend с необходимыми метаданными (`event_type`, `camera_id`, `operator_id`).
2. **Инициализация транзакции**. Backend генерирует уникальный `transaction_id` и порядковый номер на основе глобального счётчика.
3. **Предобработка**. Для каждого изображения backend считывает данные, декодирует в NumPy‑массив; если декодирование не удаётся, сразу формируется отчёт об ошибке.
4. **Инференс**. Модель YOLO-seg 11n обрабатывает изображение и выдаёт список обнаруженных объектов с координатами, классами и вероятностями.
5. **Постобработка**. Backend масштабирует координаты bounding‑box до размера исходной картинки, фильтрует дублирующиеся детекции по IoU (порог 0.5), группирует детекции по классам и подсчитывает количество, собирая агрегированную уверенность.
6. **Визуализация**. Backend рисует bounding‑box поверх копии оригинального изображения, сохраняет файл в MinIO и получает URL; сырое изображение также сохраняется.
7. **Формирование отчёта**. Создаётся словарь, содержащий идентификаторы, время обработки, список найденных и отсутствующих инструментов, процент соответствия и список предупреждений (например, `manual_count_required`, если совпадение <95 %).
8. **Сохранение**. Отчёт сохраняется в базе данных через SQLAlchemy; raw и viz картинки остаются в MinIO. Backend возвращает JSON ответ клиенту.

## 4. Алгоритмы и применяемые методы

### 4.1 Генерация синтетического датасета

Скрипт `generate_synthetic_dataset.py` создаёт набор изображений для обучения сегментационной модели. Он принимает папку с PNG‑шаблонами (классы по подпапкам), набор фонов и генерирует сцены. Основные этапы:

1. **Чтение шаблонов**. Шаблоны загружаются как BGR‑изображения и бинарные маски. Маска извлекается из альфа‑канала (если он есть) или по порогу яркости; для каждого шаблона также вычисляется серый вариант для поиска признаков.
2. **Гомографическая трансформация**. Для каждого шаблона случайно выбираются параметры масштаба, поворота, перспективы и смещения; на основе этих параметров формируется матрица гомографии. И изображение, и маска варпятся к размеру кадра одним вызовом `warpPerspective`.
3. **Добавление окклюзий**. В пределах маски случайным образом накладываются прямоугольники с полупрозрачными заливками; количество и площадь окклюзий задаются параметрами.
4. **Контроль качества**. Вырожденные сцены отбрасываются: из исходного шаблона и полученной сцены извлекают ORB/SIFT признаки, сопоставляют их (KNN + ratio‑test), оценивают гомографию методом RANSAC и принимают сцену только при достаточном числе инлаеров.
5. **Разметка**. Для каждой маски извлекается внешний контур, аппроксимируется методом Дугласа‑Пекера, нормируется в диапазон ‑0‑1; координаты сохраняются в формате YOLO‑Seg (`class_id x1 y1 x2 y2 …`).
6. **Сохранение и метаданные**. Изображения и метки помещаются в каталоги `images/train`, `images/val`, `labels/train`, `labels/val`, а файл `data.yaml` содержит путь, списки train/val и словарь имён классов.

### 4.2 Обучение модели

Для обучения модели используется Ultralytics YOLOv11 (модуль `ultralytics`). В ноутбуке `train.ipynb` реализована функция `train_yolo(data, weights, epochs, imgsz, batch, device, …)`. Основные шаги:

1. **Инициализация и установка сида**. Функция фиксирует сиды Python, NumPy и PyTorch для воспроизводимости и создаёт экземпляр модели YOLO из указанного файла весов.
2. **Настройка параметров**. Составляется словарь аргументов (`epochs`, `imgsz`, `batch`, `device`, `workers`, `project`, `name`, `seed`) и передаётся в `model.train(**args)`, что запускает обучение с валидацией на каждой эпохе.
3. **Валидация**. После обучения выполняется `model.val(...)` с тем же датасетом; возвращается объект метрик. Результаты сохраняются в директории `runs/train/<name>` (файл `best.pt`) и могут использоваться для дообучения на реальном датасете.

В проектной методологии модель первоначально обучается на синтетическом датасете, затем fine-tune проводится на размеченных реальных изображениях с уменьшенным learning rate и меньшим числом эпох. Порог `conf` для инференса выбирается эмпирически в диапазоне 0.2–0.4, в зависимости от требуемого баланса precision/recall.

### 4.3 Алгоритм инференса и постобработки

В сервисе backend при вызове `/predict/*` выполняется алгоритм `process_single_image` (или его многопоточная обёртка для batch). Он реализует следующую логику:

1. **Декодирование и сохранение**: изображение считывается из `UploadFile` и сохраняется в бакет `raw-images` в MinIO.
2. **Запуск YOLO**: модель предсказывает bounding‑box и классы для всех объектов на изображении; `conf` задан по умолчанию 0.25.
3. **Масштабирование**: координаты детекций масштабируются до исходного размера изображения и приводятся к целым значениям.
4. **Фильтрация по IoU**: чтобы избежать дублирующих срабатываний, выполняется пара двойных циклов: для каждой детекции сравнивается IoU со всеми детекциями того же класса; оставляется только наиболее уверенная детекция, если IoU > 0.5.
5. **Группировка**: оставшиеся детекции группируются по `class_id`, подсчитывается количество, список bounding‑box и средняя уверенность.
6. **Визуализация**: поверх копии изображения рисуются прямоугольники и подписи; картинка кодируется в JPEG и сохраняется в бакет `viz-images`.
7. **Формирование отчёта**: вычисляются общие показатели (количество ожидаемых/обнаруженных, процент совпадения), формируется список недостающих инструментов и список предупреждений. Также вычисляется время обработки. Отчёт возвращается в формате JSON и сохраняется в базе данных.

## 5. Компоненты пользовательского интерфейса

- **ModelInfo**. Компонент React запрашивает эндпойнт `/model/info` и отображает режим работы (CPU/GPU), количество классов и статус загрузки модели. Пользователь получает базовую справочную информацию.
- **FileUploader**. Позволяет выбрать режим загрузки (одно изображение, несколько изображений, ZIP), выбирает файлы и вызывает соответствующую функцию API. После завершения загрузки вызывает callback `onResultsReady` для отображения результатов.
- **ResultsViewer**. Принимает массив результатов и отображает подробный отчёт: количество обработанных изображений, среднее время обработки, список найденных и отсутствующих инструментов, процент совпадения, предупреждения и ссылки на сохранённые изображения. Также позволяет просмотреть JSON‑отчёт и начать новый тест.
- **API service**. Модуль `api.js` инкапсулирует вызовы к backend (single, batch, zip, model info). Базовый URL определяется переменной окружения VITE_API_URL; библиотека axios используется для отправки запросов и обработки ошибок.

## 6. Развёртывание и окружение

Сервис поставляется с файлом `docker-compose.yml`, который разворачивает четыре контейнера: backend (FastAPI), frontend (Vite + React), PostgreSQL и MinIO. Переменные окружения для каждого сервиса (адреса, пароли, имя БД, ключи MinIO) задаются в compose файле. Для локального запуска достаточно выполнить:

```bash
git clone https://github.com/marianna961/hackathon_tool_recognition.git
cd hackathon_tool_recognition/hackathon_api
docker-compose up -d
```

После старта сервисы доступны по адресам: API на `http://localhost:8000`, Swagger UI на `http://127.0.0.1:8000/docs`, UI интерфейс на `http://localhost:3000`, MinIO консоль на `http://localhost:9001` с логином и паролем `minioadmin`.

## 7. Используемые библиотеки и технологии

- **FastAPI** — асинхронный веб‑фреймворк для построения REST API.
- **Ultralytics YOLO** — библиотека для сегментации и детекции объектов; используется как для инференса, так и для обучения; функция `YOLO()` загружает веса и предоставляет методы `train()` и `val()`.
- **SQLAlchemy** — ORM для работы с PostgreSQL; используется для создания таблицы `transactions` и сохранения результатов.
- **MinIO Python SDK** — для взаимодействия с S3‑совместимым хранилищем и сохранения изображений.
- **React & Vite** — библиотека и инструмент сборки для реализации web‑интерфейса; компоненты написаны на современном JavaScript с поддержкой JSX.
- **Docker Compose** — оркестратор контейнеров; развертывает все компоненты как единый стек.
- **OpenCV и NumPy** — используются для обработки изображений, геометрических преобразований, генерации синтетических данных и визуализации результатов.

## 8. Заключение и перспективы развития

Проект предоставляет законченный прототип системы автоматического учёта авиационных инструментов. Он сочетает генерацию синтетических данных, обучение сегментационной модели и полноценный сервис с API и UI. В README репозитория обозначены направления дальнейшего развития: рефакторинг кода, интеграция с корпоративными системами, поддержка новых наборов инструментов, улучшение устойчивости модели к различным условиям освещённости и расширение функциональности интерфейса.
